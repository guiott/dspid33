<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>dsPid33: Detailed Description</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  <td id="projectlogo"><img alt="Logo" src="Ico.png"/></td>
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">dsPid33
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('descr_eng_8txt.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Detailed Description </div>  </div>
</div>
<div class="contents">
<div class="textblock"><p>===============================================================================</p>
<p><a class="anchor" id="_1"></a> [1] Watchdog is disabled during development and debug.</p>
<p><a class="anchor" id="_1a"></a>[1a] SW starts setting to OFF-state H-bridge's enable pin and turning ON the control LED. If everything is OK, during the normal work cycle, the LED blinks at a 20% duty cycle.</p>
<p>===============================================================================</p>
<p><a class="anchor" id="_2"></a>[2] AN1 Motor current reading through Rsense on H bridge</p>
<ul>
<li>_ADCInterrupt</li>
<li>Channels CH0 &amp; CH1 are used, connected to AN1 &amp; AN0</li>
<li>Reference to Avdd, Avss</li>
<li>System conversion clock</li>
<li>Conversion trigger auto</li>
<li>Auto sampling</li>
<li>ADC is in continuos auto-reading:</li>
<li>Auto-Convert Conversion Trigger + Auto-Sample Start number of samples between DMA interrupts = 64 per channel</li>
</ul>
<ul>
<li>with 10MHz oscillator</li>
<li>Clock derived from system clock, TcY = 25 ns</li>
<li>ADCS = 63</li>
<li>Tad = TCY(ADCS + 1) = 1.6 us</li>
</ul>
<ul>
<li>with 7.3728MHz oscillator</li>
<li>Clock derived from system clock, TcY = 25.234173 ns</li>
<li>ADCS = 63</li>
<li>Tad = TCY(ADCS + 1) = 1.615 us</li>
</ul>
<ul>
<li>Auto Sample Time = Tad * 31 = 50 us</li>
<li>Conversion Time (12 Tad) = Tad * 12 = 19 us</li>
<li>Total Conv. Time Simultaneous Samp. (CH0-CH1) + 2xTconv = 89 us</li>
<li>Time between interrupts = TotConvTime * 64 = 5.68 ms</li>
<li>Every about 10ms, the 32 measurements stored in DMA buffer are averaged</li>
</ul>
<p><a class="anchor" id="_2a"></a>[2a] The cumulation is done in a temporary variable. Division by 64, equivalent to a 6 bit shift, is executed in a single HW operation in the barrel shifter. So, the ADCValue variable always contains the correct value of the latest reading and it can be read in any moment, even by the interrupt routines.</p>
<p><a class="anchor" id="_2b"></a>[2b] If an overload current lasts for more then a specified time, fault procedure starts. The ADC procedure is called every 10ms, 100 x 10ms = 1s</p>
<p>============================</p>
<p>[3] N/A</p>
<p>============================</p>
<p><a class="anchor" id="_4"></a>[4]</p>
<ul>
<li>QEA1 Quadrature encoder 1 phase A</li>
<li>QEB1 Quadrature encoder 1 phase B</li>
<li>QEA2 Quadrature encoder 2 phase A</li>
<li>QEB2 Quadrature encoder 2 phase B</li>
</ul>
<p>_QEIInterrupt</p>
<p>THIS PARAMETERS ARE VALID FOR RINO ROBOTIC PLATFORM. HERE JUST AS AN EXAMPLE ON HOW TO CALCULATE THEM</p>
<ul>
<li>Motor speed = 6.000 rpm</li>
<li>Encoder = 300 cpr</li>
<li>Gear reduction ratio = 30:1</li>
<li>Wheel speed = 200 rpm</li>
<li>Encoder pulses for each wheel turn = 9,000</li>
<li>Wheel diameter = 58mm -&gt; circumference = 182.2123739mm</li>
<li>Space for each encoder pulse 1x mode Delta S = 0.020245819mm</li>
<li>Space for each encoder pulse 2x mode Delta S = 0.01012291mm</li>
<li>Space for each encoder pulse 4x mode Delta S = 0.005061455mm</li>
<li>Maximum sped = circumference * rpm / 60 = 182.212mm * 200 / 60 = 60cm/s</li>
<li>Maximum encoder frequency = (200 * 9,000) / 60 = 30KHz</li>
<li>Mininum encoder pulse duration = 0.0000333333333333s (33us = 16.6 * 2)</li>
<li>Maximum QEI frequency 4x = 30 KHz * 4 = 120KHz</li>
<li>Maximum quantity of pulses in 1ms in 4x mode = 120 -&gt; 1 pulse every 8.33us</li>
<li>Minimum speed = 182,212 * 20 / 60 = 6cm/s</li>
<li>Minmum encoder frequency = (20 * 9,000) / 60 = 3KHz</li>
<li>Maximum encoder pulse duration = 0.000333333333333s (330us = 166 * 2)</li>
<li>Minimum QEI frequency 4x mode = 3 KHz * 4 = 12KHz</li>
</ul>
<ul>
<li>Digital filter on encoder signals FILTER_DIV=(MIPS x FILTERED_PULSE)/3=(39,628,800 x 1.66667E-05)/3=220.16</li>
</ul>
<p>dividing by 128 a 10us filter is achieved shortest pulse expected(@30 KHz)is 16us.</p>
<p>Both Motor Controllers routines are the same. The motors are assembled in an opposite position each other, so the encoders' phases (QEA and QEB) on QEI1 and QEI2 must be connected in a opposite way to ensure the correct rotation.</p>
<p>============================</p>
<p>[5] OSC1 OSC0</p>
<p>N/A</p>
<p>============================</p>
<p><a class="anchor" id="_6"></a>[6] UART1 configuration</p>
<p>[6a] N/A</p>
<p><a class="anchor" id="_6b"></a>[6b] U1ARX RX serial communication with the supervisor</p>
<p>_U1RXInterrupt</p>
<p>The command string is composed by an array of unsigned char:</p>
<ul>
<li>0 - Header @</li>
<li>1 - Id 0-9 ASCII (not used here, just for compatibility)</li>
<li>2 - Cmd A-Z ASCII</li>
<li>3 - CmdLen N = 1-MAX_RX_BUFF # of bytes following (checksum included)</li>
<li>... data 1</li>
<li>...</li>
<li>... data N-1</li>
<li></li>
<li>N - Checksum 0-255 obtained by simply adding up in a 8 bit variable, all bytes composing the message (checksum itself excluded)</li>
</ul>
<p>The following bytes are decoded anyway:</p>
<ul>
<li>0) Header</li>
<li>1) Id</li>
<li>2) Cmd</li>
<li>3) CmdLen</li>
</ul>
<p>to understand how many bytes are coming, also if command parsing does not start it is needed to sincronize handshaking with the next message.</p>
<p>ERRORS</p>
<ul>
<li>-30 Current overload error</li>
<li>-20 Constants parameters error</li>
<li>-11 RX circular queue overflow</li>
</ul>
<ul>
<li>-9 Command parsing not complete</li>
<li>-8 Buffer overflow</li>
<li>-7 not a known command</li>
<li>-6 Unknown state</li>
<li>-5 Out of command sequence</li>
<li>-4 Overrun error</li>
<li>-3 Frame error</li>
<li>-2 Timeout error</li>
</ul>
<ul>
<li>-1 Checksum error</li>
</ul>
<p>Add 100 (dec) for error codes on UART2</p>
<p>RX states</p>
<ul>
<li>0 Idle</li>
<li>1 Header received</li>
<li>2 Id received and acknowledged</li>
<li>3 Id received but NOT acknowledged (receives command string but not parses)</li>
<li>4 Command received</li>
<li>5 Command length received</li>
<li>6 Waiting for command string end</li>
</ul>
<ul>
<li>99 Command string OK, start parsing</li>
</ul>
<p><a class="anchor" id="_6c"></a>[6c] In case of error (see above) routine UartRxError changes LED1 blinking frequency</p>
<p><a class="anchor" id="_6d"></a>[6d] The bytes are exchanged between second and third layers (ISR and UartRx function) through a circular buffer. ISR receives a byte, stores it in an array and increments a pointer to the array, if the pointer reaches the end of the array it is restarted to the beginning. The UartRx function has its own pointer to read the same array, incremented (in a circular way too) as soon as the byte is decoded in the current RX status. Main loop calls the UartRx function whenever the "in" pointer differs from "out" pointer.</p>
<p><a class="anchor" id="_6e"></a>[6e] TX DMA</p>
<p><a class="anchor" id="_6z"></a>[6z] All of the above is valid also for the UART2 communication</p>
<p>===============================================================================</p>
<p><a class="anchor" id="_7"></a>[7] IC2 Velocity measurement</p>
<p>_IC2Interrupt</p>
<p>THIS PARAMETERS ARE VALID FOR RINO ROBOTIC PLATFORM. HERE JUST AS AN EXAMPLE ON HOW TO CALCULATE THEM</p>
<p>The input capture is used to measure the time between two encoder's pulses, internally connected in parallel to QEA, it captures elapsed time on rising edge of the encoder's signal.</p>
<ul>
<li>Timer prescaler = 1 -&gt; period = 25,2341731266 ns</li>
<li>maximum speed (200 rpm) -&gt; 1300 TMR2 pulses per encoder tick:</li>
<li>30 samples per ms</li>
</ul>
<ul>
<li>minimum speed (20 rpm) -&gt;13000 TMR2 pulses per encoder tick:</li>
<li>3 measurements per ms</li>
</ul>
<p>TIMER2 is used in free-running mode. At each IC2 interrupt, TMR2's present value is stored and its previous value is subtracted from it; this is pulse period. Then the present value becomes the previous value, awaiting the next sample.</p>
<p><a class="anchor" id="_7a"></a>[7a] TMR2's flag has to be checked to know if there is an overflow. If yes, the difference between 0xFFFF and previous sample has to be added to present value. Using an int to count all the overflows that have occurred, the TMR2 timer become effectively a 32bit timer</p>
<p><a class="anchor" id="_7b"></a>[7b] the samples are algebraically added according to _UPDN bit, to also know the speed direction.</p>
<p>============================</p>
<p>[8] N/A</p>
<p>============================</p>
<p>[9] N/A</p>
<p>===============================================================================</p>
<p><a class="anchor" id="_10"></a>[10] RE3 Led 1, green = program running -&gt; [1a] Signaling LEDs</p>
<p>===============================================================================</p>
<p><a class="anchor" id="_11"></a>[11]</p>
<ul>
<li>RB10 H-bridge2 enable</li>
<li>RB11 H-bridge1 enable</li>
<li>PWM1H2</li>
<li>PWM1L2</li>
<li>PWM1H1</li>
<li>PWM1L1</li>
</ul>
<p>Both MCs routines are there the same. The motors, mechanically installed in opposite way each other, must be electrically connected (PWMH, PWML) in an opposite way too, to achieve the correct rotational direction.</p>
<p>PTPER = FCY / (FPWM * (PTMR Prescaler)) - 1</p>
<p>Es.:</p>
<ul>
<li>Fosc Fcy</li>
<li>7,3728MHz 39,628Mips</li>
<li>PTPER = (39,628,000 / 19,359) - 1 = 2048</li>
</ul>
<p>===============================================================================</p>
<p><a class="anchor" id="_12"></a>[12] TIMER 2</p>
<p>_T2Interrupt</p>
<p>used by Input Capture to measure speed It's loaded with value 0xFFFF at startup and it's configured in "free running 
mode", value read in TMR2 is pulse period. TMR2 overflow occurs at Tcy * 65.535 = 1.6ms, much greater than sampling period of 1ms, since it's in free running mode, it can occur no more than one time for each cycle. In this case it must to be considered in period measurement -&gt; [7a]</p>
<p>===============================================================================</p>
<p><a class="anchor" id="_13"></a>[13] TIMER 1</p>
<p>_T1Interrupt</p>
<p>used to generate 1000Hz timing clock, needed for PID and position elaboration.</p>
<ul>
<li>Tcy * 39,628 = 1.000005ms @ 7.3728MHz</li>
<li>Tcy * 40,000 = 1.000000ms @ 10MHz</li>
</ul>
<p>clocked by the same timer there are other two timed cycles as multiples of 1ms main cycle</p>
<p>============================</p>
<p>[14] N/A</p>
<p>===============================================================================</p>
<p><a class="anchor" id="_15"></a>[15] Debug Stand Alone mode. During development MCU is not connected to the supervisor, therefore the SW is a little different with the final version:</p>
<ul>
<li>a) Watchdog disabled -&gt;[1]</li>
<li>b) Checksum disabled</li>
</ul>
<p>===============================================================================</p>
<p><a class="anchor" id="_16"></a>[16] Command Parser from commands coming from both UARTs RX interrupt is disabled to avoid current command overwrite. RX buffer is 4 byte wide, the command parsing must be done before the fifth character is come to avoid OVERRUN error.</p>
<p>r=read, w=write</p>
<p>KNOWN COMMANDS</p>
<ul>
<li>A - r All mean parameters request: Vmean, Ctotal, PosX, PosY, Theta</li>
<li>a - r All detailed parameters request: Vr, Cr, Vl, Cl, PulseR, PulseL</li>
<li>c - r Continuos send mode, sends all data without request.</li>
<li>D - w Setting reference coord. X, Y computing distance [24] Mode C</li>
<li>d - w Distance from objects and targets, sensors board -&gt; dsNav</li>
<li>e - r Read error code and reset error condition</li>
<li>f - set "Console Debug" mode [30]</li>
<li>H - w Immediate Halt without decelerating ramp</li>
<li>J - w Settings PID coefficients for DistPid: DistKP, DistKI, DistKD</li>
<li>K - w Settings PID coefficients for SpeedPID: KP, KI, KD</li>
<li>k - w Settings PID coefficients for AnglePid: AngleKP, AngleKI, AngleKD</li>
<li>L - w Speed constant parameters designation: KvelR, KvelL</li>
<li>M - w Mechanical constants: Axle size, KspR, KspL</li>
<li>O - w Reference orientation angle in degrees</li>
<li>o - w Reference orientation angle in degrees as a delta of the current Theta</li>
<li>P - w Setting reference coordinates X, Y in mm [24] Mode B</li>
<li>Q - r Raw sensors data, dsNav -&gt; console</li>
<li>R - r Firmware version request</li>
<li>S - w Reference speed setting in mm/s</li>
<li>s - w Scheduler parameters setting</li>
<li>"*" - Board reset [28]</li>
<li># - start scheduler sequence [32a]</li>
<li>$ - r One row of map grid sending request [22f]</li>
<li>z - r/w send back a text string, just for debug.</li>
</ul>
<p>--- Service</p>
<ul>
<li>"$" - r all map grid sending request [22f]<ul>
<li>Receive:<ul>
<li>CmdLen = 2 Params 1</li>
</ul>
</li>
<li>Transmit:<ul>
<li>CmdLen = 80 Params 81</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>"#" - w start scheduler sequence [32a]<ul>
<li>Receive:<ul>
<li>CmdLen = 1 Params 0</li>
</ul>
</li>
<li>Transmit:<ul>
<li>N/A</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>"*" - w Board reset [28]<ul>
<li>Receive:<ul>
<li>CmdLen = 1 Params 0</li>
</ul>
</li>
<li>Transmit:<ul>
<li>N/A</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>"R" - r Firmware version request<ul>
<li>Receive:<ul>
<li>CmdLen = 1 Params 0</li>
</ul>
</li>
<li>Transmit:<ul>
<li>CmdLen = 24 Params 25 (string "Ver")</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>"c" - r Continuos send mode, sends all data without request.<ul>
<li>Receive:<ul>
<li>CmdLen = 2 Params 1 (1 char) range 0-2<ul>
<li>0=OFF</li>
<li>1=sends mean parameters</li>
<li>2=sends detailed parameters</li>
</ul>
</li>
</ul>
</li>
<li>Transmit:<ul>
<li>N/A</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>"z" - r/w send back a text string, just for debug.<ul>
<li>Receive:<ul>
<li>it just needs HEADER + character z (i.e. "@z")</li>
</ul>
</li>
<li>Transmit:<ul>
<li>CmdLen = 25 (string "Test")</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>"e" - r Read error code and reset error condition<ul>
<li>Receive:<ul>
<li>CmdLen = 1 Params 0</li>
</ul>
</li>
<li>Transmit:<ul>
<li>CmdLen = 3 Params 2 (1 int Most Significant First)</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>"f" - Set "Console Debug" mode [30]<ul>
<li>Receive:<ul>
<li>CmdLen = 1 Params 0</li>
</ul>
</li>
<li>Transmit:<ul>
<li>N/A</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>--- Navigation settings</p>
<ul>
<li>"D" - w Setting reference coord. X, Y computing distance [24] Mode C<ul>
<li>Receive:<ul>
<li>CmdLen = 3 Params 2 (1 int Most Significant First)</li>
</ul>
</li>
<li>Transmit: -N/A</li>
</ul>
</li>
</ul>
<ul>
<li>"P" - w Setting reference coordinates X, Y in mm [24] Mode B<ul>
<li>Receive:<ul>
<li>CmdLen = 5 Params 4 (2 int Most Significant First)</li>
</ul>
</li>
<li>Transmit:<ul>
<li>N/A</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>"O" - w Reference orientation angle in degrees<ul>
<li>Receive:<ul>
<li>CmdLen = 3 Params 2 (1 int Most Significant First)</li>
</ul>
</li>
<li>Transmit:<ul>
<li>N/A</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>"o" - w Reference orientation angle in degrees as a delta of the current Theta (relative)<ul>
<li>Receive:<ul>
<li>CmdLen = 3 Params 2 (1 int Most Significant First)</li>
</ul>
</li>
<li>Transmit:<ul>
<li>N/A</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>"S" - w Reference speed setting in mm/s<ul>
<li>Receive:<ul>
<li>CmdLen = 3 Params 2 (1 int Most Significant First) range -999 +999</li>
</ul>
</li>
<li>Transmit:<ul>
<li>N/A</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>"H" - w Immediate Halt without decelerating ramp<ul>
<li>Receive:<ul>
<li>CmdLen = 1 Params 0</li>
</ul>
</li>
<li>Transmit:<ul>
<li>N/A</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>--- Navigation read</p>
<ul>
<li>"A" - r All mean parameters request: Vmean, Ctotal, PosX, PosY, Theta, IdlePerc<ul>
<li>Receive:<ul>
<li>CmdLen = 1 Params 0</li>
</ul>
</li>
<li>Transmit:<ul>
<li>CmdLen = 12 Params 11 (5 int Most Significant First + 1 byte)</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>"a" - r All detailed parameters request: Vr, Cr, Vl, Cl, PulseR, PulseL<ul>
<li>Receive: -CmdLen = 1 Params 0</li>
<li>Transmit:<ul>
<li>CmdLen = 13 Params 12 (6 int Most Significant First)</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>--- Constant parameters setting</p>
<ul>
<li>"J" - w Settings PID coefficients for DistPid: DistKP, DistKI, DistKD<ul>
<li>Receive:<ul>
<li>CmdLen = 7 Params 6 (3 int MSF) = (Kx * 10000) range 0 9999</li>
</ul>
</li>
<li>Transmit:<ul>
<li>N/A</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>"K" - w Settings PID coefficients for SpeedPID: KP, KI, KD<ul>
<li>Receive:<ul>
<li>CmdLen = 13 Params 12 (6 int MSF) = (Kx * 10000) range 0 9999</li>
</ul>
</li>
<li>Transmit:<ul>
<li>N/A</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>"k" - w Settings PID coefficients for AnglePid: AngleKP, AngleKI, AngleKD<ul>
<li>Receive:<ul>
<li>CmdLen = 7 Params 6 (3 int MSF) = (Kx * 10000) range 0 9999</li>
</ul>
</li>
<li>Transmit:<ul>
<li>N/A</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>"L" - w Speed constant parameters designation: KvelR, KvelL<ul>
<li>Receive:<ul>
<li>CmdLen = 5 Params 4 (1 long MSF) = Kvel</li>
</ul>
</li>
<li>Transmit:<ul>
<li>N/A</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>"M" - w Mechanical constants: Axle size, KspR, KspL<ul>
<li>Receive:<ul>
<li>CmdLen = 13 Params 12 (3 long MSF)</li>
</ul>
</li>
<li>Transmit:<ul>
<li>N/A</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>--- Sensors</p>
<ul>
<li>"d" - w Distance from objects and targets, sensors board -&gt; dsNav<ul>
<li>Receive:<ul>
<li>CmdLen = 7 Params 6 (6 bytes)</li>
</ul>
</li>
<li>Transmit:<ul>
<li>N/A</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>"Q" - r Raw sensors data, dsNav -&gt; console: PosX,PosY,Theta,VObX[0-2],VObY[0-2]<ul>
<li>Receive:<ul>
<li>CmdLen = 1 Params 0</li>
</ul>
</li>
<li>Transmit:<ul>
<li>CmdLen = 19 Params 18 (9 int Most Significant First)</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>===============================================================================</p>
<p><a class="anchor" id="_17"></a>[17] CheckSum calculation obtained by simply adding up in a 8 bit variable, all bytes composing the message (checksum itself excluded).</p>
<p>unsigned char UartChkSum (unsigned char *Buff,unsigned int BuffSize)</p>
<p>Needed parameters are:</p>
<ul>
<li>Pointer to buffer containing data to add</li>
<li>Numbers of characters to add</li>
</ul>
<p>Returns:</p>
<ul>
<li>Checksum value in a char variable (0-255)</li>
</ul>
<p>===============================================================================</p>
<p><a class="anchor" id="_18"></a>[18] Parameters trasmission</p>
<p>Send to the supervisor the requested parameters, with the correct handshake.</p>
<p>To do this:</p>
<ul>
<li>Fills TX buffer with<ul>
<li>header</li>
<li>data -CheckSum</li>
</ul>
</li>
<li>Sets TX flag</li>
</ul>
<p>void <a class="el" href="ds_p_i_d33__prototypes_8h.html#ac098f07c32fe84a9dfa3452021b3eb9f">TxParameters(char TxCmd,int TxCmdLen, int PortNumber)</a></p>
<p>Needed parameters are:</p>
<ul>
<li>Command to send</li>
<li>Number of bytes to send (Data are stored in UartTmpBuff buffer)</li>
<li>Port number to use for sending</li>
</ul>
<p>Eg.:</p>
<ul>
<li>to send params 1, 2, 3, of "A" type to port 1:<ul>
<li>UartTmpBuff[0]=1;</li>
<li>UartTmpBuff[1]=2;</li>
<li>UartTmpBuff[2]=3;</li>
<li>TxParameters('A',3,1);</li>
</ul>
</li>
</ul>
<p>===============================================================================</p>
<p><a class="anchor" id="_19"></a>[19] Encoder pulses counts are added up, algebraically, in "Space" variable every 1ms.</p>
<p>Value sent is pulses count as an integer.</p>
<p>PID and speed elaboration -&gt; [4] [7]</p>
<p>PID and speed elaboration is done every millisecond. At each encoder pulse the period counts are added up, when 1ms interrupt occurs it calculates the mean speed by averaging all samples (summation/index). In the 1ms period, speed is elaborated from a minimum of 3 times (@ 20 rpm) to a maximum of 30 times (@ 200 rpm). Maximum quantization error is less 1/1000, but in this case the average in 1ms is done on 30 samples. At minimum speed the average is with 3 samples only but quantization error is less 1/10000.</p>
<p><a class="anchor" id="_19a"></a>[19a] Input Capture interrupts may happens very frequently, so measured values can be modified during elaboration. To avoid that, they are stored in a temporary variable and resetted before starting PID and speed calculation.</p>
<p><a class="anchor" id="_19b"></a>[19b] first IC interrupt resets the count, therefore index starts from second one, that marks the first complete useful cycle.</p>
<p><a class="anchor" id="_19c"></a>[19c]</p>
<ul>
<li>if index = 0 there was no pulses in a 1ms slot</li>
<li>if index != 0 -&gt; averages speed, otherwise speed = 0.</li>
</ul>
<ul>
<li>Minimum measurable speed is 3.5 cm/s with capture on every rising edge (1X mode)</li>
<li>Minimum measurable speed is 1.8 cm/s with capture on every edge (2X mode)</li>
</ul>
<p>Constant to calculate speed in meter/second:</p>
<ul>
<li>V = S/T speed is calculated averaging all samples in 1ms</li>
<li>Space = SPACE_ENC_1X * IcIndx<ul>
<li>= space covered in one encoder pulse * number of pulses in 1ms</li>
</ul>
</li>
<li>Time = TCY * IcPeriod<ul>
<li>= single TMR period * summation of periods occurred in 1ms</li>
</ul>
</li>
<li>Single TMR period = TCY = 1 / FCY</li>
</ul>
<ul>
<li>V = (SPACE_ENC_1X * IcIndx) / (TCY * IcPeriod) =<ul>
<li>= (SPACE_ENC_1X / TCY) * (IcIndx / IcPeriod) =</li>
<li>= (SPACE_ENC_1X * FCY) * (IcIndx / IcPeriod) =</li>
<li>= Kvel * (IcIndx / IcPeriod)</li>
</ul>
</li>
</ul>
<ul>
<li>Kvel = SPACE_ENC_1X * (FCY) to obtain speed in m/s</li>
</ul>
<p>Two different way of elaboration was experimented:</p>
<ul>
<li>1 Classic: float variables used -&gt; high accuracy<ul>
<li>const float KvelFloat = (K_VEL); // 401.1588 -float VelFloat; // floating point speed (m/s)</li>
</ul>
</li>
</ul>
<ul>
<li>VelFloat = KvelFloat*IcIndxTmp/IcPeriodTmp; // mean speed in 1ms</li>
<li>PID_MES = Q15(VelFloat); // measured speed in m/s (fractional)</li>
</ul>
<p>elaboration is heavy due to the float variables and to one more conversion from float to fractional needed before calling PID routine. This method requires an overall time of 60us (on a 30Mips dsPIC)</p>
<ul>
<li>2- with "long" variables (still 32 bit). -const long KvelLong = 13145170; // Kvel &lt;&lt; 15<ul>
<li>long VelLong; // speed in a "long"</li>
</ul>
</li>
</ul>
<ul>
<li>VelLong = KvelLong*IcIndxTmp/IcPeriodTmp;</li>
<li>PID_MES = (VelLong); // speed measured in m/s (fractional)</li>
</ul>
<p>The constant is doubled with capture on every rising edge (1X mode -&gt; SPACE_ENC_1X) in this mode the IC receives half interrupts then in 2X mode:</p>
<p>Kvel = 26290341</p>
<p>The constant is calculated just at compiling, multiplying it's value by 2^15. The integer elaboration is much faster and the final result is already multiplied by 2^15, already in fractional format for PID routine.</p>
<p>This method requires an overall time of 20us (on a 30Mips dsPIC).</p>
<p>Comparing both methods, the final result differs just for the least significant bit.</p>
<p><a class="anchor" id="_19d"></a>[19d] PID</p>
<p>Microchip Code Example CE019</p>
<p>Declare a PID Data Structure of type "tPID" named PIDstruct</p>
<p>The data structure contains a pointer to derived coefficients in X-space and pointer to controller state (history) samples in Y-space.</p>
<p>So declare variables for the derived coefficients and the controller history samples:</p>
<ul>
<li>abcCoefficient[3]</li>
<li>controlHistory[3]</li>
</ul>
<p>The abcCoefficients referenced by the PIDstruct data structure are derived from the gain coefficients, Kp, Ki and Kd</p>
<p>So, declare Kp, Ki and Kd in an array</p>
<ul>
<li>kCoeffs[] = {0,0,0}</li>
</ul>
<p><a class="anchor" id="_19e"></a>[19e] To convert a fractional variable in a long one it must be divided by 2^15.</p>
<p>To scale the error range returned from PID routine (-1 +1) in PWM range (0 -4096 in LAP mode) it has to be multiplied by 2^11, so:</p>
<ul>
<li>(fract &gt;&gt; 15) &lt;&lt; 11 -&gt; PWM = PID_OUT &gt;&gt; 4 + 2048</li>
</ul>
<p>This is true with PWM period = 2048</p>
<p>in this configuration PWM F=19,359Hz, 12bit resolution @ Fcy=39.628 MHz</p>
<p><a class="anchor" id="_19f"></a>[19f] Acceleration and deceleration of the motors are executed with a rising or falling ramp in order to avoid heavy mechanical strain and wheel slippering. The deceleration is faster then the acceleration to avoid bumps with the obstacles during braking.</p>
<p>When a new speed value is set with "W" command, current and final speeds are to be considered. These could be both positive or negative and the final speed could be algebraic greater or smaller than the final one.</p>
<p>All possible combinations are: </p>
<pre>
<code>
if(Present Vel )  &amp;&amp;  Final Vel     Ramp step=       End of ramp test
       &gt;= 0         &gt; Vel Iniz       + Acc          if Vel Ist &gt; Vel Fin
       &gt;= 0         &lt; Vel Iniz       - Dec          if Vel Ist &lt; Vel Fin
       &gt;= 0         &gt; Vel Iniz       + Dec          if Vel Ist &gt; Vel Fin
       &gt;= 0         &gt; Vel Iniz       - Acc          if Vel Ist &lt; Vel Fin
</code>
</pre><p>Increase or decrease of speed is done at each PID cycle (1ms) with a very small step:</p>
<p>with ACC = 0.00025 m every 1ms -&gt; to increase from 0 to 0.5 m/s it needs</p>
<p>2000ms -&gt; mean Vel = 0.25 m/s -&gt; 50 cm of space covered</p>
<p>with DEC = 0.0025 m every 1ms -&gt; to decrease from 0.5 a 0 m/s it needs</p>
<p>200ms -&gt; mean Vel = 0.25 m/s -&gt; 5 cm of space covered before stop</p>
<p>===============================================================================</p>
<p><a class="anchor" id="_20"></a>[20] DMA</p>
<p>===============================================================================</p>
<p><a class="anchor" id="_21"></a>[21] To allow SIM debugging. Otherwise MPLAB stay hanged forever</p>
<p>===============================================================================</p>
<p><a class="anchor" id="_22"></a>[22] Odometry &amp; dead reckoning</p>
<p>The coordinates of the current position of the robot is achieved with an algorithm elaborated starting from G.W. Lucas' paper "A Tutorial and Elementary
Trajectory Model for the Differential Steering System of Robot Wheel Actuators" available on Internet:</p>
<ul>
<li><a href="http://rossum.sourceforge.net/papers/DiffSteer/DiffSteer.html">http://rossum.sourceforge.net/papers/DiffSteer/DiffSteer.html</a></li>
</ul>
<p><a class="anchor" id="_22a"></a>[22a] In order to avoid computational errors (divide by zero) and waste of the controller time, a check has to be done in advance on both Spmm[R] and Spmm[L] variables, defining a quasi-zero value SPMIN, that takes care of minimal mechanical and computational approximations.</p>
<ul>
<li>If absolute value of SaMinusSb (Spmm[R]-Spmm[L]) is less than SPMIN, the platform is traveling in a nearly straight line and we can use without approximations the method in [6] from already mentioned Lucas paper</li>
</ul>
<ul>
<li>If absolute value of SrPlusSl (Spmm[R]+Spmm[L]) is less than SPMIN, the platform is pivoting around its own vertical axis without translation.</li>
</ul>
<p><a class="anchor" id="_22aa"></a>[22aa] With the computation described above the resulting orientation is obtained according to the trigonometry convention: 0 degrees is along the X axis, the angle value increases counterclockwise</p>
<p>In order to have the orientation in geographic convention (0 degrees is north and angle value increases clockwise: 90° is east, 180° south, 270° west) we use the left wheel as the external one in the rotation curve instead of right wheel:</p>
<ul>
<li>Trigonometric SaMinusSb = Spmm[R]-Spmm[L]</li>
<li>Geographic SaMinusSb = Spmm[L]-Spmm[R]</li>
</ul>
<p>and the cos is swapped with sin in the formulas.</p>
<p>ALL THE FOLLOWING PROCEDURES WILL BE COMPUTED WITH GEOGRAPHIC CONVENTION ONLY.</p>
<p><a class="anchor" id="_22b"></a>[22b] Field mapping</p>
<p>The unknown field is mapped in a grid of CELL_SIZE mm * CELL_SIZE mm cells.</p>
<p>Maximum field dimension is MAP_SIZE mm * MAP_SIZE mm.</p>
<p>E.g. MAP_SIZE = 12,000 mm CELL_SIZE = 50 mm -&gt; # of cells is:</p>
<p>12,000/50 * 12,000/50 = 57,600</p>
<p>In order to store the grid in a matrix, each cell is defined with</p>
<p>8 / VAR_PER_BYTE bits.</p>
<p>In the example of 4 variables for each byte (2 bits for each cell) we have a total memory occupation of 14,400 Bytes</p>
<ul>
<li>The Y index is MAP_SIZE modulo CELL_SIZE</li>
<li>The X index is (MAP_SIZE modulo CELL_SIZE) / VAR_PER_BYTE</li>
</ul>
<p>E.g.:</p>
<ul>
<li>Y index MAX = 12,000 / 50 = 240 (0-239)</li>
<li>X index max = 12,000 / 50 / 4 = 60 (0-59)</li>
</ul>
<p>each variable is split in 4 2bit variables with a sub-index ranging from 0 to 3, in this way a 57,600 cells fields can be mapped in a 14,400 byte array</p>
<p>If there is the need to store more levels for each cell, a compromyze could be setting a CELL_SIZE of 100mm. Dividing by 2 the number of cells per side divides the memory occupation by 4, allowing 2 variables for each byte instead of 4 (16 positions instead of 4) and still increasing</p>
<p>field dimensions:</p>
<ul>
<li>MAP_SIZE = 15,000 mm</li>
<li>CELL_SIZE = 100 mm</li>
<li># of cells is: 15,000 / 100 * 15,000 /100 = 22.500</li>
<li>Y index MAX = 15,000 / 100 = 75 (0-74)</li>
<li>X index max = 15,000 / 100 / 2 = 150 (0-149)</li>
</ul>
<p>each variable is split in 2 4bit variables with a sub-index ranging from 0 to 1, in this way a 22,500 cells fields can be mapped in a 11,250 byte array</p>
<p>Bot can starts from any position in the field, these will be the reference coordinates (0,0) in its reference system.</p>
<p>To translate bot reference system coordinates to 50x50 matrix index, their values must be "normalized" in 0-75 range:</p>
<p>Xindx = (Xrel + 75) mod 75</p>
<p>Index is the remainder of division, in a range 0-74.</p>
<p>A range check must be performed before to avoid overflow.</p>
<p>If HALF_MAP_SIZE is added instead of MAP_SIZE, the 0,0 coordinates are located at the center of the field and start available coordinates range from -HALF_MAP_SIZE to +HALF_MAP_SIZE.</p>
<p>To divide with remainder, a dsPIC built-in function can be used such as: __builtin_divmodud</p>
<p>Description:</p>
<p>Issues the 16-bit architecture's native unsigned divide support with the same restrictions given in the dsPIC30F/33F Programmers Reference Manual (DS70157). Notably, if the quotient does not fit into a 16-bit result, the results (including remainder) are unexpected. This form of the builtin function will capture both the quotient and remainder.</p>
<ul>
<li>Prototype:<ul>
<li>unsigned int __builtin_divmodud(</li>
<li>unsigned long dividend, unsigned int divisor,</li>
<li>unsigned int *remainder);</li>
</ul>
</li>
<li>Argument:<ul>
<li>dividend number to be divided</li>
<li>divisor number to divide by</li>
<li>remainder pointer to remainder</li>
</ul>
</li>
<li>Return Value:<ul>
<li>Quotient and remainder.</li>
</ul>
</li>
<li>Assembler Operator / Machine Instruction:<ul>
<li>divmodud</li>
</ul>
</li>
</ul>
<p><a class="anchor" id="_22c"></a>[22c] Field mapping procedure (Slam) is called to store in the cell related to the current position, some information about the environment.</p>
<p>In case of 2 bits per cell, four different values can be assigned:</p>
<ul>
<li>n = 00 unknown cell</li>
<li>n = 01 cell visited 1 time</li>
<li>n = 02 cell visited more than 1 time</li>
<li>n = 03 obstacle found</li>
</ul>
<p>In case of 4 bits per cell, 16 different values can be assigned:</p>
<ul>
<li>n = 00 unknown cell</li>
<li>n = 01 to 07 obstacle found n times</li>
<li>n = 08 to 10 cell visited n-7 times</li>
<li>n = 11 Gas target found</li>
<li>n = 12 Light target found</li>
<li>n = 13 Sound target found</li>
<li>n = 14 to 15 available for further expansions</li>
</ul>
<p>if the procedure is called with Cell flag = 0, it means that the bot is on the cell(X, Y) right now.</p>
<p>If Cell flag = 1, it means that the cell(X,Y) contains and obstacle</p>
<p><a class="anchor" id="_22d"></a>[22d] The "Cell" parameter is used to drive the behavior of the procedure, the value of the cell addressed is modified in this way:</p>
<ul>
<li>0 = do nothing, just return the value of the cell addressed</li>
<li>1 = Obstacle found, increment value from 1 to 7</li>
<li>2 = I Was Here, increment value of the cell from 08 to 10 meaning that the robot travelled on that cell 1 or more times. This overrides obstacle info</li>
<li>5 = Gas target found. This and following override any other info</li>
<li>6 = Light target found</li>
<li>7 = Sound target found</li>
</ul>
<p><a class="anchor" id="_22e"></a>[22e] The field is dinamicaly shifted when boundaries are reached. If the robot goes beyond 7500mm, the new range is -7400 to 7600, -7300 to 7700 and so on, with a global history of a 15,000 x 15,000 mm field around the robot</p>
<p><a class="anchor" id="_22f"></a>[22f] The console asks for the content of the grid map. It asks a matrix row at a time. In the requesting command there is the index of the row to send.</p>
<p>The responding packet is composed by:</p>
<ul>
<li>1° byte = index of the matrix as requested in the range 0 - Y_SIZE</li>
<li>2° byte = byte H for Xshift (see [22g])</li>
<li>3° byte = byte L for Xshift</li>
<li>4° byte = byte H for Yshift</li>
<li>5° byte = byte L for Yshift</li>
</ul>
<p>byte 6 to 81 one row of the map grid at index requested</p>
<p><a class="anchor" id="_22g"></a>[22g] Because the map is stored in a matrix using modulo, when the robot is traveling beyond the MAX limit or behind the MIN limit (in both X or Y axis), this fact has to be stored in some way to be able to read the exact X, Y coordinates when reading the matrix back.</p>
<p>Xshift, and the corresponding Yshift, means how much the matrix index has wrapped. E.g.: if Xshift = 4, means that reading cells from 4 to MAX we have the real coordinates, from 0 to 4 we have values relative to coordinates beyond old MAX limit and we have lost the old MIN limits. If Xshift = -4, means that from 0 to MAX - 4 we have real coordinates, from MAX - 4 to MAX we have coordinates behind old MIN limit.</p>
<p>Starting position</p>
<ul>
<li>Xshift = 0</li>
<li>Xmax = 7499 -&gt; index = 150</li>
<li>X = 0 -&gt; index = 75</li>
<li>Xmin = -7500 -&gt; index = 0</li>
</ul>
<p>when robot travels beyond 7500 (e.g.7800)</p>
<ul>
<li>Xshift = 4</li>
<li>Xmax = 7800 -&gt; index = 3</li>
<li>X = 7700 -&gt; index = 2</li>
<li>X = 7600 -&gt; index = 1</li>
<li>X = 7500 -&gt; index = 0</li>
<li>X = 7499 -&gt; index = 150</li>
<li>X = 0 -&gt; index = 75</li>
<li>Xmin = -7200 -&gt; index = 4</li>
<li>X = -7500 to -7300 -&gt; no more available</li>
</ul>
<p>when robot travels behind -7500 (e.g.-7800)</p>
<ul>
<li>Xshift = -4</li>
<li>X = 7200 to 7500 -&gt; no more available</li>
<li>Xmax = 7199 -&gt; index = 150 - 4</li>
<li>X = 0 -&gt; index = 75</li>
<li>X = -7500 -&gt; index = 0</li>
<li>X = -7600 -&gt; index = 150 - 1</li>
<li>X = -7700 -&gt; index = 150 - 2</li>
<li>Xmin = -7800 -&gt; index = 150 - 3</li>
</ul>
<p>===============================================================================</p>
<p><a class="anchor" id="_23"></a>[23] Angle PID</p>
<p>PID procedure to maintain the desired orientation. The orientation angle obtained by dead reckoning procedure [21] is used as measured output feedback for this PID. PID output is used to control the rotation angular velocity of the bot around its vertical axis. This allows to keep the heading corresponding to "ThetaDes" value.</p>
<p><a class="anchor" id="_23a"></a>[23a] With this optimization, the rotation to point to the desired orientation, will never be greater than PI rad (180 degrees) positive (CW) or negative (CCW).</p>
<p><a class="anchor" id="_23b"></a>[23b] In order to work with fractional variables, needed by PID function, the value of the angle is normalized to a half circle angle (PI radians), so 0.25 means a PI/4 angle (45 deg), 0.5 means a PI/2 angle (90 deg) and so on.</p>
<p><a class="anchor" id="_23c"></a>[23c] The optimization in [23a] already returns the error value between measured and reference values. This value can be used as "mes" input of PID if "ref" is set to 0.</p>
<p><a class="anchor" id="_23ca"></a>[23ca] Because the reference value is continuously set to zero, the history (the integral part of the PID) must be reset before setting a new value, otherwise the error is cumulated at every new setup. To do this the PIDInit() procedure can be used</p>
<p><a class="anchor" id="_23d"></a>[23d] This is the limit for Angle PID correction, the maximum amount of speed to add or subtract to the mean speed value (VelDesM) to obtain the speed of each wheel (VelDes[R], VelDes[L]) in order to have the desired rotation of the bot. To convert fract to int it requires a division by 2^15. To keep the limit at 256 it requires a multiplication by 2^8, so &gt;&gt;15 + &lt;&lt;8 = &gt;&gt;7</p>
<p><a class="anchor" id="_23e"></a>[23e] As aforementioned, the rotation angular velocity is obtained adding DeltaV to the speed of left wheel and subtracting it to the speed of right wheel, with geographic (CW = positive) convention. If the speed of one wheel exceeds positive or negative maximum controllable speed, that speed will be set to MAX_ROT_SPEED and the speed of the other wheel will be set to (MAX_ROT_SPEED + or - (2*DeltaV)) resulting in a lower VelDesM.</p>
<p><a class="anchor" id="_23f"></a>[23f] VelFin[x] are the values (converted fractional) to use as references for speed PIDs. This part of the code decides the slope of the ramp to acc/decelerate -&gt; [19f]</p>
<p>===============================================================================</p>
<p><a class="anchor" id="_24"></a>[24] Navigation</p>
<p>Procedure to control speed and orientation in order to navigate safely avoiding obstacles and reaching the desired position when needed.</p>
<p>The supervisor receives navigation command from outside by serial1 interface (telemetry) or by serial2 interface (navigation board).</p>
<p>Different navigation strategies can be used:</p>
<ul>
<li>A - travel at a given speed in a given direction (VelDes, deltaDes).</li>
<li>B - travel toward a given point with coordinates XDes, YDes.</li>
<li>C - travel for a given distance in a given direction (DistDes, deltaDes).</li>
</ul>
<p>Mode A: Distance procedure is disabled (DIST_ENABLE_FLAG = 0), only the PID control "Angle PID" is used on the supervisor.</p>
<ul>
<li>Command "W" (set VelDesM)</li>
<li>Command "O" (set ThetaDes absolute) or command "o" (set ThetaDes relative)</li>
</ul>
<p>Mode B: Distance procedure enabled (DIST_ENABLE_FLAG = 1), the desired speed VelDes is calculated by this procedure as a negative delta of VelDesM and it is used as in mode A.</p>
<p>Speed vector (magnitude and direction) is computed as a function of the current coordinates and the destination coordinates, dinamicaly corrected in order to avoid obstacle.</p>
<p>Angle is used as reference input for "Angle PID". With angle and VelDes available, the speed control of the wheels runs as in mode A.</p>
<ul>
<li>Command "W" (set VelDesM)</li>
<li>Command "x" (set PosXdes, PosYdes)</li>
</ul>
<p>Mode C: Distance procedure enabled (DIST_ENABLE_FLAG = 1), the destination coordinates Xdes, Ydes are computed once at the beginning as a function of input parameters DistDes, ThetaDes. After that, everything goes as in mode B.</p>
<ul>
<li>Command "W" (set VelDesM)</li>
<li>Command "O" (set ThetaDes absolute) or command "o" (set ThetaDes relative)</li>
<li>Command "D" (set PosXdes, PosYdes as a function of Dist and ThetaDes)</li>
</ul>
<p><a class="anchor" id="_24a"></a>[24a] If a new orientation is set, the previous computed coordinates are no more valid in B or C mode. The A mode is automatically selected.</p>
<p><a class="anchor" id="_24b"></a>[24b]</p>
<ul>
<li>The "Speed PID" control is executed every 1ms.</li>
<li>The "Angle PID" is executed every CYCLE1_TMO ms.</li>
<li>The Distance procedure is executed every CYCLE2_TMO times.</li>
</ul>
<p>With current values it means:</p>
<ul>
<li>"Speed PID" every 1ms</li>
<li>"Angle PID" every 10ms</li>
<li>Distance every 50ms</li>
</ul>
<p><a class="anchor" id="_24c"></a>[24c] The magnitude (not the phase) of speed vector control through Distance procedures starts only when the bot is close to the destination point.</p>
<p>The speed reduction is inversely proportional to the distance from the goal. Because it is computed only if Dist &lt; MIN_GOAL_DIST, VelDecr will ever be &lt; 1.</p>
<p>The total speed reduction is the combination of both Obj and Goal effects.</p>
<p><a class="anchor" id="_24d"></a>[24d] The VelDesM speed is decreased multiplying it by the VelDecr value.</p>
<p>VelDecr range is 0 to 1 in order to have full speed when distance is greater than MIN_GOAL_DIST or no obstacles found, and speed = 0 when target is reached.</p>
<p>If the Distance procedure is not enabled, VelDecr is reset to 1 (full speed).</p>
<p><a class="anchor" id="_24e"></a>[24e] The Virtual Force Field (VFF) method was developed by Johann Borenstein and Yoram Koren at the the university of Michigan in 1989.</p>
<p>For further reference about the VFF method visit:</p>
<p><a href="http://www-personal.engin.umich.edu/~johannb/vff&vfh.htm">http://www-personal.engin.umich.edu/~johannb/vff&amp;vfh.htm</a></p>
<p>To reach the goal in the unknown environment all of the objects must be considered. Assuming a vectorial force that attracts the robot towards the final destination and a series of force that reject it caused by all obstacles, we can vectorially add all of them in order to compute the orientation of the robot. It allows to dinamicaly find the path towards the target at any given position avoiding obstacles.</p>
<p>Translating the Borenstein algorythm in code it should be something like this: </p>
<div class="fragment"><pre class="fragment">CellV=<a class="code" href="ds_p_i_d33_8c.html#a0045cdba351669e55136652c9b95b39b">GetMap</a>(X_grid, Y_grid);
<span class="keywordflow">if</span>((CellV &gt; 0) &amp;&amp; (CellV &lt; 8))
{
  DistObst=sqrt(pow((X_grid-Cx),2)+pow((Y_grid-Cy),2));
  <span class="keywordflow">if</span>(DistObst != 0)
  {
    Frx+=Fcr*CellV/pow(DistObst,2)*(X_grid-Cx)/DistObst;
    Fry+=Fcr*CellV/pow(DistObst,2)*(Y_grid-Cy)/DistObst;
  }
}
*
</pre></div><p>Exploring a 16 x 16 cells could result in a 1024 iterations of that calculi that can require 300ms of machine time. Because the explored field around the robot is always a fixed number of discrete cells, it is easy to precalculate once the X and Y component for the repulsive vectors of each possible obstacle placed in the cells. This saves a lot of calculi leading to a theorethical maximum time of 20ms if every cell is occupied by an obstacle. This can be afforded even with a 50ms cycle time. Once computed the table it is evident that the contribute of an obstacle far more than 1.5m from the robot is very low, so the field to be scanned can be reduced saving even more time.</p>
<p><a class="anchor" id="_24f"></a>[24f]</p>
<p>N/A</p>
<p><a class="anchor" id="_24g"></a>[24g] Sensors on the sides are 45° oriented, the object is considered at the distance measured by the sensor board and at this angle, relatively to current orientation, even if the measurement cone of the sensors cause an uncertainty.</p>
<p>...............................................................................</p>
<p>[Summarizing]</p>
<ul>
<li>VelDesM is the desired speed for the center of the robot, set via COMM port</li>
<li>VelDecr is calculated by the Distance() function in order to approach the target exactly with speed = 0</li>
<li>RealVel = VelDesM - VelDecr</li>
<li>DeltaVel is the angular rotation speed of the robot calculated by the <a class="el" href="ds_p_i_d33_8c.html#abf3685fb9a5c5a777ac2d0712f8e501a">Orientation()</a> function (Angle PID) in order to maintain the right orientation</li>
<li>VelDes[R] = RealVel - DeltaVel</li>
<li>VelDes[L] = RealVel + DeltaVel</li>
</ul>
<p>if one of the VelDes reach the maximum allowable speed the VelDesM is decreased during the maneuvre</p>
<p>VelDes[x] is used as Vref for speed PID functions</p>
<p>===============================================================================</p>
<p><a class="anchor" id="_25"></a>[25] Idle time estimation</p>
<p>The program most of the time is in idle main loop just controlling flags set or reset by ISRs.</p>
<p>We know:</p>
<ul>
<li>How much idle loop lasts without serving ISRs:IDLE_TIME_PERIOD</li>
<li>How many times idle loop was executed: IdleCount</li>
<li>Sampling time: IdleSample * IDLE_SAMPLE_TIME</li>
</ul>
<p>were IDLE_SAMPLE_TIME = (ASK_PARAM_TMO * ASK_PARAM_ALL_TMO)</p>
<p>Idle percentage is:</p>
<p>(IdleCount * IDLE_TIME_PERIOD) / (IdleSample * IDLE_SAMPLE_TIME)</p>
<p><a class="anchor" id="_25a"></a>[25a] IDLE_TIME_PERIOD is the time measured with stopwatch in SIM from start to end</p>
<p>===============================================================================</p>
<p><a class="anchor" id="_26"></a>[26]</p>
<p>N/A</p>
<p>===============================================================================</p>
<p><a class="anchor" id="_27"></a>[27]</p>
<p>N/A</p>
<p>===============================================================================</p>
<p><a class="anchor" id="_28"></a>[28] Board reset</p>
<p>The same as boot, the EEPROM parameters are not modified. For security reason, the command has to be sent three times consecutively. The Supervisor disables all interrupts.</p>
<p>===============================================================================</p>
<p><a class="anchor" id="_29"></a>[29] parameters are sent as long var with 4 bytes.</p>
<p>They are multiplied in advance by a power of ten in order to maintain precision so, they need to be divided by the same number to get back the float var with the right precision</p>
<p><a class="anchor" id="_29a"></a>[29a] Starting constant parameters for Rino robotic platform</p>
<p>Speed calculation K in micron/second = 298536736</p>
<p>Speed calculation K in m/s as a power of 2 to simplify dsPID elaboration</p>
<div class="fragment"><pre class="fragment"><a class="code" href="ds_p_i_d33__definitions_8h.html#a4d89a8c0bd42593f537de9654a0187c3">Kvel</a>[] &lt;&lt; 15 ( x 2^15)
<span class="keywordtype">long</span>, 2 x 4 bytes = 8 byte

<a class="code" href="ds_p_i_d33__definitions_8h.html#a4d89a8c0bd42593f537de9654a0187c3">Kvel</a>[1] = 26290341;             <span class="comment">// EEvalue[0]-[1]</span>
<a class="code" href="ds_p_i_d33__definitions_8h.html#a4d89a8c0bd42593f537de9654a0187c3">Kvel</a>[2] = 26290341;             <span class="comment">// EEvalue[2]-[3]</span>

<span class="comment">// KP, KI, KD x Angle PID</span>
<span class="comment">// fractional, 3 x 2 = 6 bytes</span>

<a class="code" href="ds_p_i_d33__definitions_8h.html#aa3921b5835fead737e5bf98dbebf4fde">ANGLE_KP</a>=Q15(0.9999);   <span class="comment">// EEvalue[4]</span>
<a class="code" href="ds_p_i_d33__definitions_8h.html#ad3c6108576a8c14dc64cf980dcbeaa07">ANGLE_KI</a>=Q15(0.2);              <span class="comment">// EEvalue[5]</span>
<a class="code" href="ds_p_i_d33__definitions_8h.html#a8ac275be5870eac565e6abe883f71027">ANGLE_KD</a>=Q15(0.0001);   <span class="comment">// EEvalue[6]</span>

<span class="comment">// KP, KI, KD x Speed PID MC1 e MC2 (dsPID) in int x 10.000 </span>
<span class="comment">// int, 2MCs x 3params x 2bytes = 12 bytes</span>

Kpid[0][0] = 6000;              <span class="comment">// EEvalue[10]</span>
Kpid[0][1] = 6000;              <span class="comment">// EEvalue[11]</span>
Kpid[1][0] = 2000;              <span class="comment">// EEvalue[12]</span>
Kpid[1][1] = 2000;              <span class="comment">// EEvalue[13]</span>
Kpid[2][0] = 200;               <span class="comment">// EEvalue[14]</span>
Kpid[2][1] = 200;               <span class="comment">// EEvalue[15]</span>

<span class="comment">// constants for traveled distance calculation: SPACE_ENC_4X in mm      </span>
<span class="comment">// float, 2 x 4 = 8 bytes</span>

<a class="code" href="ds_p_i_d33__definitions_8h.html#acce085fb3e400e13f46a7d32a7fdc6bc">Ksp</a>[1] = 0.00506145483078356;   <span class="comment">// EEvalue[16]-[17]</span>
<a class="code" href="ds_p_i_d33__definitions_8h.html#acce085fb3e400e13f46a7d32a7fdc6bc">Ksp</a>[2] = 0.00506145483078356;   <span class="comment">// EEvalue[18]-[19]</span>

<span class="comment">// base width, distance between center of the wheels</span>
<span class="comment">// float, 1 x 4 = 4 bytes</span>
<a class="code" href="ds_p_i_d33__definitions_8h.html#a55fe808c96551f1979b3cceb6bb84e30">Axle</a> = 185.2222;                <span class="comment">// EEvalue[20]-[21]</span>

<span class="preprocessor">#define SEMI_AXLE Axle/2</span>
</pre></div><p>===============================================================================</p>
<p><a class="anchor" id="_30"></a>[30] Console debug</p>
<p>JUST FOR DEBUG</p>
<p>The SW acts as a loopback, sending back to the console some values proportional to other received values, in order to check communication and right decoding and encoding of received and transmitted packets.</p>
<p>===============================================================================</p>
<p><a class="anchor" id="_31"></a>[31] Continuos send mode, sends all data without request.</p>
<ul>
<li>0=OFF</li>
<li>1=sends mean parameters</li>
<li>2=sends detailed parameters</li>
</ul>
<p>As a debug or data logging mode. All data requested will be sent continuosly until set to 0, without further request and without any protocol or handshake, just raw data tab delimited and CR terminated.</p>
<p>The command can be sent via a simple communication program sending the following strings </p>
<pre>
<code>
	as decimal 
		OFF          64 0 99 2 0 165
		mean values  64 0 99 2 1 166
		details      64 0 99 2 2 167</code></pre><pre><code>	as HEX
		OFF         40 00 63 02 00 A5
		mean values 40 00 63 02 01 A6
		details     40 00 63 02 02 A7
</code>
</pre><p>Data will be received as two bytes for each int value:</p>
<p>Mean values</p>
<p>speedH-speedL currH-currL PosXH-PosXL PosYH-PosYL ThetaH-ThetaL-LF-CR</p>
<p>16 bytes</p>
<p>Detailed values</p>
<p>VRH-VRL VLH-VLL CurrRH-CurrRL CurrLH-CurrLL TickRH-TickRL TickRH-TickRL-CR-CF</p>
<p>19 bytes</p>
<p>===============================================================================</p>
<p><a class="anchor" id="_32"></a>[32] Scheduler</p>
<p>Acting as a "Washing Machine Timer" it schedules the behavior of the bot executing a series of primitives in sequence. The sequence is written in some arrays and it is synchronized by external events.</p>
<p>Some higher priority events (e.g.: obstacles found by external sensors) can override scheduling.</p>
<p>Each kind of primitive has his own code: </p>
<pre>
<code>
code   Theta      Speed     X   Y   D
0       0           0	
1       *           V
2       *           *(2)            D
3       Theta       *(2)
4       Theta(1)    *(2)    X   Y
5                   *(2)    X   Y
6       wait
</code>
</pre><p>notes</p>
<p>"*" means previous, unchanged value</p>
<p>(1) Theta computed as a direction toward X, Y coordinates</p>
<p>(2) keeps speed if V = FFFF, otherwise sets also speed</p>
<pre>
<code>
Description
0	stop                    - end of sequence
1	keep previous angle     - set speed
2	keep angle and speed(2)	- set distance
3	keep speed(2)           - set angle
4	keep speed(2)           - set angle toward X, Y
5	keep speed(2)           - walk toward X, Y
6	wait n ms</code></pre><pre><code>Units	
	Angle(deg)	
	Speed(mm/s)	
	X(mm)	
	Y(mm)	
	D(mm)	
	Delay(n x 50ms)</code></pre><pre><code>Meaning of parameters
code    A       B       C
0
1       V
2       V(2)    D
3       V(2)    Theta
4       V(2)    X       Y
5       V(2)    X       Y
6       Delay</code></pre><pre><code>Example of usage for an UMBmark:</code></pre><pre><code>index  code   parameters        description
0       6       100             wait 5s
1       4       0 4000          heading to coordinates 0, 4000
2       5       300 0 4000      travel at V=300mm / till coordinates 0, 4000
3       4       4000 4000       heading to coordinates 4000, 4000
4       5       300 4000 4000   travel at V=300mm / till coordinates 4000, 4000
5       4       4000 0          heading to coordinates 4000, 0
6       5       300 4000 0      travel at V=300mm / till coordinates 4000, 0
7       4       0 0             heading to coordinates 0, 0
8       5       300 0 0         travel at V=300mm / till coordinates 0, 0
9       3       0               heading to Theta = 0
10      0                       stop</code></pre><pre><code>int SchedValues[16][4]= { {6,100,0,0},
                              {4,0,0,4000},
                              {5,300,0,4000},
                              {4,0,4000,4000},
                              {5,300,4000,4000},
                              {4,0,4000,0},
                              {5,300,4000,0},
                              {4,0,0,0},
                              {5,300,0,0},
                              {3,0,0,0},
                              {0,0,0,0},
                              {0,0,0,0},
                              {0,0,0,0},
                              {0,0,0,0},
                              {0,0,0,0},
                              {0,0,0,0} };
</code>
</pre><p><a class="anchor" id="_32a"></a>[32a] The scheduler is enabled only if Sensor Board sends a parameter. If any navigation command come from outside it ovverrides the current sequence.</p>
<p>===============================================================================</p>
<p><a class="anchor" id="_33"></a>[33] The storage in program memory of different parameters is executed with the code from Microchip application note AN1095:</p>
<p>Emulating Data EEPROM for PIC18 and PIC24 Microcontrollers and dsPIC Digital Signal Controllers</p>
<p>===============================================================================</p>
<p><a class="anchor" id="_34"></a>[34] Compilation switches</p>
<p>this software can be used with some kind of board, prototypes or definitive. With this "#defines" different configurations are available without rewriting the code. Just comment or uncomment the relative lines.</p>
<p>Right now these configurations available are:</p>
<ul>
<li>oscillator 7.3728MHz or 10MHz</li>
<li>dsPIC33FJ128MC802 (28 pins)<ul>
<li>prototype or 990.011 Droids board</li>
</ul>
</li>
<li>dsPIC33FJ128MC804 (44 pins)<ul>
<li>dsNav prototype board or Robocontroller board</li>
</ul>
</li>
</ul>
<p><a class="anchor" id="_34a"></a>[34a] Reads config setting from code instead of simulated eeprom in order to save writing cycles during debug</p>
<p><a class="anchor" id="_34b"></a>[34b] ifdef oscillator quartz = 10MHz, else = 7.3728MHz</p>
<p><a class="anchor" id="_34c"></a>[34c] ifdef configuration for prototype, else for 990.011 Droids board 990.011 board requires a dsPIC33FJ128MC802</p>
<p><a class="anchor" id="_34d"></a>[34d] Another prototype, it also requires a 44 pin dsPIC</p>
<p><a class="anchor" id="_34e"></a>[34e] Don't consider obstacle distance revealed by SensorsBoard</p>
<p>=============================================================================== </p>
</div></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div>
  <div id="nav-path" class="navpath">
    <ul>
<html>

	<head>
<meta name=Titolo content=dsNavCon>
<meta name="Parole chiave" content="">
<meta http-equiv=Content-Type content="text/html; charset=utf-8">
<meta name=ProgId content=Word.Document>
<meta name=Generator content="Microsoft Word 11">
<meta name=Originator content="Microsoft Word 11">
<link rel=File-List href="../dsNavCon/dsNavCon_file/filelist.xml">
<title>dsNavCon Odometry</title>

<style id="dynCom" type="text/css"><!-- --></style>
<script language="JavaScript"><!--
function msoCommentShow(anchor_id, com_id)
{
	if(msoBrowserCheck()) 
		{
		c = document.all(com_id);
		if (null != c)
			{
			a = document.all(anchor_id);
			var cw = c.offsetWidth;
			var ch = c.offsetHeight;
			var aw = a.offsetWidth;
			var ah = a.offsetHeight;
			var x  = a.offsetLeft;
			var y  = a.offsetTop;
			var el = a;
			while (el.tagName != "BODY") 
				{
				el = el.offsetParent;
				x = x + el.offsetLeft;
				y = y + el.offsetTop;
				}
			var bw = document.body.clientWidth;
			var bh = document.body.clientHeight;
			var bsl = document.body.scrollLeft;
			var bst = document.body.scrollTop;
			if (x + cw + ah / 2 > bw + bsl && x + aw - ah / 2 - cw >= bsl ) 
				{ c.style.left = x + aw - ah / 2 - cw; }
			else 
				{ c.style.left = x + ah / 2; }
			if (y + ch + ah / 2 > bh + bst && y + ah / 2 - ch >= bst ) 
				{ c.style.top = y + ah / 2 - ch; }
			else 
				{ c.style.top = y + ah / 2; }
			c.style.visibility = "visible";
}	}	}
function msoCommentHide(com_id) 
{
	if(msoBrowserCheck())
		{
		c = document.all(com_id);
		if (null != c)
		{
		c.style.visibility = "hidden";
		c.style.left = -1000;
		c.style.top = -1000;
		} } 
}
function msoBrowserCheck()
{
	ms = navigator.appVersion.indexOf("MSIE");
	vers = navigator.appVersion.substring(ms + 5, ms + 6);
	ie4 = (ms > 0) && (parseInt(vers) >= 4);
	return ie4;
}
if (msoBrowserCheck())
{
	document.styleSheets.dynCom.addRule(".msocomanchor","background: infobackground");
	document.styleSheets.dynCom.addRule(".msocomoff","display: none");
	document.styleSheets.dynCom.addRule(".msocomtxt","visibility: hidden");
	document.styleSheets.dynCom.addRule(".msocomtxt","position: absolute");
	document.styleSheets.dynCom.addRule(".msocomtxt","top: -1000");
	document.styleSheets.dynCom.addRule(".msocomtxt","left: -1000");
	document.styleSheets.dynCom.addRule(".msocomtxt","width: 33%");
	document.styleSheets.dynCom.addRule(".msocomtxt","background: infobackground");
	document.styleSheets.dynCom.addRule(".msocomtxt","color: infotext");
	document.styleSheets.dynCom.addRule(".msocomtxt","border-top: 1pt solid threedlightshadow");
	document.styleSheets.dynCom.addRule(".msocomtxt","border-right: 2pt solid threedshadow");
	document.styleSheets.dynCom.addRule(".msocomtxt","border-bottom: 2pt solid threedshadow");
	document.styleSheets.dynCom.addRule(".msocomtxt","border-left: 1pt solid threedlightshadow");
	document.styleSheets.dynCom.addRule(".msocomtxt","padding: 3pt 3pt 3pt 3pt");
}
// --></script>
<style><!--
 /* Font Definitions */
@font-face
	{font-family:"Times New Roman";
	panose-1:0 2 2 6 3 5 4 5 2 3;}
@font-face
	{font-family:"Courier New";
	panose-1:0 2 7 3 9 2 2 5 2 4;}
@font-face
	{font-family:Wingdings;
	panose-1:0 5 2 1 2 1 8 4 8 7;}
@font-face
	{font-family:"ＭＳ 明朝";}
@font-face
	{font-family:Optima;
	panose-1:0 2 0 5 3 6 0 0 2 0;}
@font-face
	{font-family:"Lucida Grande";}
 /* Style Definitions */
p.MsoNormal, li.MsoNormal, div.MsoNormal
	{margin:0cm;
	margin-bottom:.0001pt;
	font-size:12.0pt;
	font-family:"Times New Roman";}
h1
	{margin:0cm;
	margin-bottom:.0001pt;
	text-align:center;
	text-indent:0cm;
	tab-stops:list 18.0pt;
	font-size:36.0pt;
	font-family:Optima;}
h2
	{margin-top:12.0pt;
	margin-right:0cm;
	margin-bottom:3.0pt;
	margin-left:0cm;
	text-indent:0cm;
	mso-line-height-alt:17.0pt;
	tab-stops:31.2pt list 36.0pt;
	font-size:18.0pt;
	font-family:Optima;}
h3
	{margin-top:12.0pt;
	margin-right:0cm;
	margin-bottom:3.0pt;
	margin-left:0cm;
	text-indent:14.2pt;
	line-height:17.0pt;
	tab-stops:48.2pt list 50.2pt;
	font-size:14.0pt;
	font-family:Optima;
	color:black;}
h4
	{margin-top:12.0pt;
	margin-right:0cm;
	margin-bottom:3.0pt;
	margin-left:43.2pt;
	text-indent:-14.85pt;
	line-height:17.0pt;
	tab-stops:48.2pt list 64.35pt;
	font-size:12.0pt;
	font-family:Optima;
	color:black;}
h5
	{margin-top:6.0pt;
	margin-right:0cm;
	margin-bottom:3.0pt;
	margin-left:50.4pt;
	text-indent:-22.05pt;
	line-height:17.0pt;
	tab-stops:list 64.35pt left 90.7pt 99.25pt;
	font-size:12.0pt;
	font-family:Optima;
	color:black;}
p.MsoCommentText, li.MsoCommentText, div.MsoCommentText
	{margin:0cm;
	margin-bottom:.0001pt;
	font-size:12.0pt;
	font-family:"Times New Roman";}
p.MsoHeader, li.MsoHeader, div.MsoHeader
	{margin:0cm;
	margin-bottom:.0001pt;
	text-align:center;
	font-size:36.0pt;
	font-family:Optima;
	font-style:italic;
	font-weight:bold;}
p.MsoFooter, li.MsoFooter, div.MsoFooter
	{margin:0cm;
	margin-bottom:.0001pt;
	tab-stops:center 240.95pt right 481.9pt;
	font-size:12.0pt;
	font-family:"Times New Roman";}
span.MsoCommentReference
	{font-size:9.0pt;}
p.MsoTitle, li.MsoTitle, div.MsoTitle
	{margin:0cm;
	margin-bottom:.0001pt;
	text-align:center;
	font-size:18.0pt;
	font-family:Optima;
	font-weight:bold;}
a:link, span.MsoHyperlink
	{color:blue;
	text-decoration:underline;
	text-underline:single;}
a:visited, span.MsoHyperlinkFollowed
	{color:purple;
	text-decoration:underline;
	text-underline:single;}
p.MsoPlainText, li.MsoPlainText, div.MsoPlainText
	{margin:0cm;
	margin-bottom:.0001pt;
	font-size:12.0pt;
	font-family:Courier;}
table.MsoNormalTable
	{font-size:10.0pt;
	font-family:"Times New Roman";}
p.MsoCommentSubject, li.MsoCommentSubject, div.MsoCommentSubject
	{margin:0cm;
	margin-bottom:.0001pt;
	font-size:12.0pt;
	font-family:"Times New Roman";}
p.Titolone, li.Titolone, div.Titolone
	{margin-top:0cm;
	margin-right:0cm;
	margin-bottom:0cm;
	margin-left:21.6pt;
	margin-bottom:.0001pt;
	text-align:center;
	text-indent:-21.6pt;
	mso-line-height-alt:17.0pt;
	tab-stops:list 21.6pt;
	font-size:36.0pt;
	font-family:Optima;
	font-weight:bold;}
p.Glossario1, li.Glossario1, div.Glossario1
	{margin-top:12.0pt;
	margin-right:0cm;
	margin-bottom:3.0pt;
	margin-left:0cm;
	text-align:center;
	mso-line-height-alt:17.0pt;
	tab-stops:31.2pt;
	font-size:18.0pt;
	font-family:Optima;
	font-weight:bold;}
p.Glossario2, li.Glossario2, div.Glossario2
	{margin-top:12.0pt;
	margin-right:0cm;
	margin-bottom:3.0pt;
	margin-left:0cm;
	line-height:17.0pt;
	tab-stops:48.2pt;
	font-size:14.0pt;
	font-family:Optima;
	color:black;
	font-weight:bold;}
p.testo2, li.testo2, div.testo2
	{margin-top:0cm;
	margin-right:0cm;
	margin-bottom:0cm;
	margin-left:51.05pt;
	margin-bottom:.0001pt;
	text-align:justify;
	tab-stops:center 233.9pt right 404.0pt;
	font-size:10.0pt;
	font-family:Optima;
	color:black;}
p.Tabella, li.Tabella, div.Tabella
	{margin:0cm;
	margin-bottom:.0001pt;
	text-align:justify;
	tab-stops:center 233.9pt right 404.0pt;
	font-size:10.0pt;
	font-family:Optima;
	color:black;}
p.Testo1, li.Testo1, div.Testo1
	{margin-top:0cm;
	margin-right:0cm;
	margin-bottom:0cm;
	margin-left:34.0pt;
	margin-bottom:.0001pt;
	text-align:justify;
	tab-stops:35.45pt 3.0cm center 212.65pt right 14.0cm;
	font-size:10.0pt;
	font-family:Optima;}
p.tabellina, li.tabellina, div.tabellina
	{margin-top:0cm;
	margin-right:0cm;
	margin-bottom:0cm;
	margin-left:34.0pt;
	margin-bottom:.0001pt;
	text-align:justify;
	tab-stops:63.8pt 148.85pt 177.2pt 219.7pt 269.35pt 12.0cm 382.75pt;
	font-size:8.0pt;
	font-family:Optima;
	font-weight:bold;}
p.Testo3, li.Testo3, div.Testo3
	{margin-top:0cm;
	margin-right:0cm;
	margin-bottom:0cm;
	margin-left:65.2pt;
	margin-bottom:.0001pt;
	text-align:justify;
	tab-stops:111.2pt;
	font-size:10.0pt;
	font-family:Optima;}
p.Testo4, li.Testo4, div.Testo4
	{margin-top:0cm;
	margin-right:0cm;
	margin-bottom:0cm;
	margin-left:90.7pt;
	margin-bottom:.0001pt;
	text-align:justify;
	tab-stops:111.2pt 5.0cm 6.0cm;
	font-size:10.0pt;
	font-family:Optima;}
p.Testo2Italic, li.Testo2Italic, div.Testo2Italic
	{margin-top:0cm;
	margin-right:0cm;
	margin-bottom:0cm;
	margin-left:51.05pt;
	margin-bottom:.0001pt;
	text-align:justify;
	tab-stops:center 233.9pt right 404.0pt;
	font-size:10.0pt;
	font-family:Optima;
	color:black;
	font-style:italic;}
p.Testo3Italic, li.Testo3Italic, div.Testo3Italic
	{margin-top:0cm;
	margin-right:0cm;
	margin-bottom:0cm;
	margin-left:65.2pt;
	margin-bottom:.0001pt;
	text-align:justify;
	tab-stops:111.2pt;
	font-size:10.0pt;
	font-family:Optima;
	font-style:italic;}
@page Section1
	{size:595.3pt 841.9pt;
	margin:42.55pt 2.0cm 42.55pt 2.0cm;}
div.Section1
	{page:Section1;}
@page Section2
	{size:595.3pt 841.9pt;
	margin:42.55pt 2.0cm 42.55pt 2.0cm;}
div.Section2
	{page:Section2;}
 /* List Definitions */
@list l0:level1
	{text-indent:-18.0pt;
	tab-stops:list 36.0pt;
	font-family:Symbol;}
@list l0:level2
	{text-indent:-18.0pt;
	tab-stops:list 72.0pt;
	font-family:"Courier New";}
@list l1:level1
	{text-indent:-18.0pt;
	tab-stops:list 36.0pt;
	font-family:Symbol;}
@list l2:level1
	{text-indent:-18.0pt;
	tab-stops:list 36.0pt;
	font-family:Symbol;}
@list l3:level1
	{margin-left:21.6pt;
	text-indent:-21.6pt;
	tab-stops:list 21.6pt;}
@list l3:level2
	{margin-left:28.8pt;
	text-indent:-28.8pt;
	tab-stops:list 28.8pt;}
@list l3:level3
	{margin-left:36.0pt;
	text-indent:-36.0pt;
	tab-stops:list 36.0pt;}
@list l3:level4
	{margin-left:43.2pt;
	text-indent:-43.2pt;
	tab-stops:list 43.2pt;}
@list l3:level5
	{margin-left:50.4pt;
	text-indent:-50.4pt;
	tab-stops:list 50.4pt;}
@list l3:level6
	{margin-left:57.6pt;
	text-indent:-57.6pt;
	tab-stops:list 57.6pt;}
@list l3:level7
	{margin-left:64.8pt;
	text-indent:-64.8pt;
	tab-stops:list 64.8pt;}
@list l3:level8
	{margin-left:72.0pt;
	text-indent:-72.0pt;
	tab-stops:list 72.0pt;}
@list l3:level9
	{margin-left:79.2pt;
	text-indent:-79.2pt;
	tab-stops:list 79.2pt;}
@list l4:level1
	{margin-left:0cm;
	text-indent:0cm;
	tab-stops:list 18.0pt;
	font-size:1.0pt;}
@list l4:level2
	{margin-left:0cm;
	text-indent:0cm;
	tab-stops:list 36.0pt;
	font-size:14.0pt;}
@list l4:level3
	{margin-left:0cm;
	text-indent:14.2pt;
	tab-stops:list 50.2pt;
	font-size:10.0pt;
	font-weight:bold;
	font-style:normal;}
@list l4:level4
	{margin-left:43.2pt;
	text-indent:-14.85pt;
	tab-stops:list 64.35pt;
	font-size:8.0pt;}
@list l4:level5
	{margin-left:50.4pt;
	text-indent:-22.05pt;
	tab-stops:list 64.35pt;
	font-size:8.0pt;}
@list l4:level6
	{margin-left:57.6pt;
	text-indent:-57.6pt;
	tab-stops:list 57.6pt;}
@list l4:level7
	{margin-left:64.8pt;
	text-indent:-64.8pt;
	tab-stops:list 64.8pt;}
@list l4:level8
	{margin-left:72.0pt;
	text-indent:-72.0pt;
	tab-stops:list 72.0pt;}
@list l4:level9
	{margin-left:79.2pt;
	text-indent:-79.2pt;
	tab-stops:list 79.2pt;}
@list l5:level1
	{margin-left:72.0pt;
	text-indent:-18.0pt;
	tab-stops:list 72.0pt;
	font-family:Symbol;}
ol
	{margin-bottom:0cm;}
ul
	{margin-bottom:0cm;}
--></style>
</head>

	<body lang=IT link=blue vlink=purple style="tab-interval:36.0pt">
		<div class=Section1>
			<div style="position:relative; width:805px; height:35; -adbe-g:p;">
			  <div style="position:relative; width:350; height:35; -adbe-g:p;">
			    <div style="position:absolute; top:-2px; left:8px; width:81px; height:35px;"> <span lang=EN-US style='font-size:12.0pt;font-family:"Times New Roman"'><a href="http://www.guiott.com/Rino/index.html"><img src="http://www.guiott.com/Rino/rino.jpg" alt="" width="81" height="35" align="absmiddle" border="0"></a></span></div>
			    <div colspan="2" style="position:absolute; top:7px; left:95px; width:175px; height:22px; -adbe-c:c; text-align: left;">
			      <div align="right"> <strong><font size="-1">updated on 13-12-2011</font></strong></div>
		        </div>
		      </div>
            </div>
	</div>
		<div class=Section1 align="center"></div>
		<div class=Section1>
			<p class=MsoNormal align=center style="text-align:center;tab-stops:right 411.1pt"></p>
		</div>
	</body>

</html>






